/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 13.04.1 ] */

/* [wxMaxima: title   start ]
Rostock Calibration
   [wxMaxima: title   end   ] */

/* [wxMaxima: comment start ]
Copyright © 2013 Peter Hercek.
You can use, modify, and redistribute this under GNU GENERAL PUBLIC LICENSE Version 3.
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
This document helps to find proper values for these firmware parameters: tower positions, diagonal rod length,
and endstop position offsets.
* We assume that all your diagonal rods have the same length (although the common length is not know
precisely). You can easily achieve this with a jig. (Note: If your diagonal rods do not have the same length it will
introduce rotations to your platform. These will not have that big impact on z-height but will have significant
impact on x/y precision)
* We assume that the towers are parallel and hope that the bed is perpendicular to the towers. Ensuring
that the towers are parallel should not be hard - just drill both top and bottom plate at once. Making sure the
bed is perpendicular is hard but callibration can take care of that ... except that your prints will be as skewed
as your bed is :-)
* We assume no other auto level is active (e.g. Johann's auto leveling cannot be enabled).
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
A note on manual leveling (i.e. doing the same as this notebook without running it):
1) level at the tower bases by adjusting endstops
2) level the center by adjusting diagonal rod length
    * if head is too high/low in the center then you need to lengthen/shorten diagonal rod length
3) level the points at the far end of a tower base (i.e. between the other two towers)
   * moving tower radially has the biggest z-height impact on the oposite side of the tower
      (if it is symetricaly high/low on the oposite side then you need to move it nearer/further in firmware)
   * moving tower diagonally has the biggest z-height impact just to the left/right of the tower - one side
     is going up and the other side is going down
     (if e.g. left side is up and right is down then you need to move tower in firmware to the right)
This manual leveling is very iterative. If you fix something a bit, the fix will have impact on z-heights on
all the other positions. So you must start from the beginning after each fix. It is best to fix the biggest
errors first. If you cannot decide which one is the biggest one then go in the order of the points above.
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
Lets go back to this math supported approach.
In this document:
* coordinates are refered as x,y,z;
* towers are refered as a,b,c;
* diagonal rod length is r;
* imprecise values (because of incorrect firmware parameters) have prefix i;
* tower carriage position offsets are marked as α, β, γ for towers a, b, c respectively;
* tower carriage positions (coordinates on towers) are ta, tb, tc.
We want to make our coordinate system as fixed as possible. Lets mark (x,y) coordinates of towers (a, b, c) as
xa, ya, xb, yb, xc, yc. We place the coordinate system so that:  xa = -xb, ya = yb, yc = -2*ya. This will allow us to
define tower positions with only 3 numbers. If the base plate is done precisely then it will be the same as the
firmware defaults computed from DELTA_RADIUS (see how tower positions are computed from delta radius
in Configuration.h).
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]

Define your geometry as specified in the firmware here:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
ir : 250.015 $
ixa : -107.048 $
iya : -61.990 $
ixc : -1.477 $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
These tower positions and their errors are fixed because of the limitations on how we place our coordinate system.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
ixb : - ixa $
xb : -xa $
iyb : iya $
yb : ya $
iyc : -2*iya $
yc : -2*ya $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Equations for the firmware. These equations work with imprecise firmware parammeters which leads to incorrect
z value at heatbed (and also incorrect x and y values - depends on the exact path we are approaching the
heatbed). We need these equations to get ta,tb,tc from them but we are not going to really use them since
firmware will report ta, tb, tc directly when we query the current position (M114)). Here they are just for reference.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
Acur : (ix-ixa)^2 + (iy-iya)^2 + (iz-ta)^2 - ir^2 = 0 $
Bcur : (ix-ixb)^2 + (iy-iyb)^2 + (iz-tb)^2 - ir^2 = 0 $
Ccur : (ix-ixc)^2 + (iy-iyc)^2 + (iz-tc)^2 - ir^2 = 0 $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Equations for precise towerPositions/diagonalRod with carriage positions on towers (ta,tb,tc) adjusted by
offsets (α,β,γ). These equations are valid when the head is at the heatbed (z=0).
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
A : (x-xa)^2 + (y-ya)^2 + (ta+α)^2 - r^2 = 0 $
B : (x-xb)^2 + (y-yb)^2 + (tb+β)^2 - r^2 = 0 $
C : (x-xc)^2 + (y-yc)^2 + (tc+γ)^2 - r^2 = 0 $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Lets precisely tie (r,xa,xb,xc,ya,yb,yc,α,β,γ) for one (ta,tb,tc) representing one point on heatbed.
We do it by getting rid of x and y.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
XEq : solve([A-B], [x]) ;
YEq : solve([A+B-2*C], [y]) ;
ZEq : subst( rhs(XEq[1]), x, subst(rhs(YEq[1]), y, C) ) ;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Now we will measure errors in at least 7 positions (x,y).
The best points are the center, near each tower base, and most far away from each tower base.
The measurement will be done by touching printhead with heatbed at these points and reading
out the carriage positions on towers as reported by firmware (ta,tb,tc).
The data format is [[ta,tb,tc]]. Define the measured data here:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
m :
[[224.65, 224.66, 224.51]
,[255.79, 170.06, 170.45]
,[230.95, 230.95, 128.09]
,[170.06, 255.81, 168.96]
,[128.55, 230.85, 230.26]
,[169.91, 169.91, 255.76]
,[230.83, 128.55, 231.34]
] $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Adjust cariage positions on towers by z-probe measured z heights at positions nearest to the tower bases.
The z-heights are zta, ztb, ztc. This is done to make lbfgs later more stable, but it is not sure it really helps.
At the beginning, it looked like it is helping but may be there were some other errors too. The point is: this
should not be needed.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
zta : 7.39 $
ztb : 7.40 $
ztc : 7.39 $
mm : map( lambda([lst], [ lst[1]-zta, lst[2]-ztb, lst[3]-ztc ]), m) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
We define function FAll which is sum of squares of ZEq over all the measured data points. This the error
function we want to minimize. If we can get it to zero for some vector [r,xa,ya,xc,α,β,γ], then that vector
should represent the precise firmware configuration parameters.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
define( ZFn(ta, tb, tc), lhs(ZEq)^2 ) ;
define( FOne(r,xa,ya,xc,α,β,γ), ''( funmake(ZFn,mm[1]) ) ) $
define( FAll(r,xa,ya,xc,α,β,γ), ''( lsum( funmake(ZFn,l), l, mm ) ) ) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
OK, and here we go to find the best firmware parameters (r, xa, ya, xc, α, β, γ). We will do it by minimizing FAll.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
load( lbfgs ) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
First we try to compute all the precise parameters at once. In theory this should work. We should get the correct
firmware parameters in one step. The equation should have only two real minimums. One corresponing to the
diagonal rods pointing down and small absolute values of  (α,β,γ) and one corresponding to the diagonal rods
poining up and huge absolute values of  (α,β,γ). Since our starting point has α=β=γ=0 we should get to the
proper minimum.
Unfortunately this did not work well. The result tended to have too big values for r. Notice that we can measure
diagonal rod with precision of ±1 mm easily so if the result claims it should be 5 mm longer than what we
measured, then it is obviously wrong.
So our function does not converge as well as we would like. Possible reason is that we do not provide precise
values for measured values at headbed (imprecise microswitches, steppers do not move continously, M114
reports tower positions with only 2 decimal palces). Since the order of equation is six, these no so big measurement
errors can have significant consequences. Other option is that there is an error in our mathematical model,
or there are errors in firmware, .... or many other options.
We skipped this direct computation. But you can try. Maybe a miracle will happen.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
RV : lbfgs( FAll(r,xa,ya,xc,α,β,γ), [r,xa,ya,xc,α,β,γ], [ir,ixa,iya,ixc,0,0,0], 0.0001, [1,1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
So we skipped the direct computation above and instead computed the vector [r,xa,ya,xc,α,β,γ] in parts
below. First [α,β,γ] part, then [xa, ya, xc] part, and [r] at the end.
After the computation we fixed the firmware parameters with computed [r,xa,ya,xc,α,β,γ] and measured
new set of points m (see above), and then computed again, and fixed, and computed ...
When we started with bed leveling errors within 0.2 mm, we needed 3 loops to achieve bed leveling within
0.005 mm. We did not bother more.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
RVαβγ : lbfgs( FAll(ir,ixa,iya,ixc,α,β,γ), [α,β,γ], [0,0,0], 0.002, [1,1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
sublis( append([r=ir,xa=ixa,ya=iya,xc=ixc],RVαβγ), FOne(r,xa,ya,xc,α,β,γ) );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
RVxayaxc : lbfgs( sublis( RVαβγ, FAll(ir,xa,ya,xc,α,β,γ) ), [xa,ya,xc], [ixa,iya,ixc], 0.000001, [1,1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
sublis( append([r=ir], RVxayaxc, RVαβγ), FOne(r,xa,ya,xc,α,β,γ) );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
RVr : lbfgs( sublis( append(RVxayaxc,RVαβγ), FAll(r,xa,ya,xc,α,β,γ) ), [r], [ir], 0.000001, [1,1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
sublis( append(RVr, RVxayaxc, RVαβγ), FOne(r,xa,ya,xc,α,β,γ) );
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
append( RVr, RVxayaxc, RVαβγ );
/* [wxMaxima: input   end   ] */

/* Maxima can't load/batch files which end with a comment! */
"Created with wxMaxima"$
